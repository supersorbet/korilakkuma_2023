// SPDX-License-Identifier: Frensware
/* ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣴⠟⠛⠉⠉⠙⠻⣶⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣄⣀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡟⠁⡀⠀⠀⠀⠀⠀⠈⢻⣧⠀⢀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⢀⣴⠿⠛⠉⠈⠉⠛⠿⣦⡀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠟⠛⠛⠛⢷⣆⢀⣠⣴⠾⠟⠛⠋⠉⠉⠉⠉⠉⠉⠙⠛⠳⢶⣾⣇⠀⠀⠀⠀⠀⠀⣀⣘⣷⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣇⠀⠀⠀⣠⡿⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣦⣀⣴⠿⠛⠋⠙⢿⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⣤⡾⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⡀⠀⠀⠀⣾⠃
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⡄⣠⣾⠋⠀
⠀⠀⣠⣤⣦⣤⣀⣤⣄⡀⠀⠀⠀⠀⢰⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⠋⠁⠀⠀
⠀⣾⠋⠀⠀⠀⠀⠀⠉⠻⣧⠀⠀⠀⣼⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀
⠸⣿⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⣿⠀⠀⠀⠀⠀⢠⣤⣤⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀
⠀⠻⣷⣀⠀⠀⠀⠀⠀⢸⣟⡀⠀⠀⢿⡄⠀⠀⠀⠀⠈⠉⠉⠉⠡⠀⠀⢠⣾⣦⠀⠀⠀⠀⠛⠿⠿⠟⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀
⠀⠀⢸⡷⠀⠀⠀⠀⠀⠈⠻⣷⠀⠀⠘⣷⡀⠀⠀⠀⠀⠀⠀⠀⢸⠀⣠⣴⠟⢿⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡇⠀⠀⠀
⠀⠀⢸⣇⠀⠀⠀⠀⠀⠀⠀⣿⠂⠀⠀⠘⢷⣄⠀⠀⠀⠀⠀⠀⠈⠢⣈⠁⠀⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⡟⠀⠀⠀⠀
⠀⠀⠀⠻⢷⣄⠀⠀⠀⠀⠀⠹⣧⡀⠀⠀⠀⠛⢷⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡾⠟⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠹⣷⣄⣠⣤⣤⣄⣈⣿⣷⠀⠀⠀⠀⠈⣹⡿⠿⣶⣶⠶⡟⠛⠉⢻⡛⠷⢶⣤⣄⣤⣤⣤⣶⠾⠛⠉⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠈⠉⠁⠀⠀⠉⠉⠁⠀⠀⠀⠀⠀⣼⡟⠀⣰⣿⠁⡰⠀⠀⠀⠀⠈⠳⡄⢹⣿⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠸⣿⡷⢶⣶⣤⣤⣤⣤⣤⣶⠿⠿⠷⠀⠀⢹⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡄⠀⠀⠈⣿⠀⣤⣤⣤⣤⢰⡟⠁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠿⢶⣶⣶⠟⠀⠸⠿⠿⠇⠈⢿⣦⣤⣴⡾⠟⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⡿⠛⠻⣶⣤⣄⣀⣀⣤⣴⠿⠃⠀⠀⠀⠀⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿⠁⠀⠀⠀⠀⠀⠈⠉⠉⠀⠀⡀⠀⠀⠀⠀⢀⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣄⡀⢀⣠⡾⠻⠶⠶⠶⠾⣿⠇⠀⠀⠀⢀⣾⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠋⠉⠀⠀⠀⠀⠀⠀⢻⣦⣄⣀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/

pragma solidity ^0.8.23;

import {IERC20, SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {IUniswapV2Factory} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import {IUniswapV2Router02} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol";

import {Ownable, OwnableRoles} from "solady/src/auth/OwnableRoles.sol";
import {SafeTransferLib} from "solady/src/utils/SafeTransferLib.sol";
import {FixedPointMathLib} from "solady/src/utils/FixedPointMathLib.sol";
import {LibString} from "solady/src/utils/LibString.sol";
import {ReentrancyGuard} from "solady/src/utils/ReentrancyGuard.sol";
import {SafeCastLib} from "solady/src/utils/SafeCastLib.sol";

/*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
/*                           ERRORS                           */
/*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

/// @dev Thrown when a zero address is provided where it's not allowed.
error ZeroAddress();

/// @dev Thrown when the balance is insufficient for a transfer or operation.
/// @param available The available balance.
/// @param required The required balance.
error InsufficientBalance(uint256 available, uint256 required);

/// @dev Thrown when the transfer amount exceeds the allowance.
/// @param available The available allowance.
/// @param required The required allowance.
error TransferAmountExceedsAllowance(uint256 available, uint256 required);

/// @dev Thrown when a swap operation is attempted but swaps are not enabled.
error SwapNotEnabled();

/// @dev Thrown when an operation would exceed the maximum supply of tokens.
error ExceedsMaxSupply();

/// @dev Thrown when an operation involves a blacklisted address.
/// @param addr The blacklisted address.
error BlacklistedAddress(address addr);

/// @dev Thrown when a transaction amount exceeds the allowed limit.
/// @param from The sender address.
/// @param to The recipient address.
/// @param amount The transaction amount.
error TxAmountLimited(address from, address to, uint256 amount);

/// @dev Thrown when a balance exceeds the allowed holding limit.
/// @param to The address holding the tokens.
/// @param balance The balance exceeding the limit.
error HoldLimitExceeded(address to, uint256 balance);

/// @dev Thrown when an operation is attempted on an inactive pool.
error PoolNotActive();

/// @dev Thrown when a zero input is provided where it's not allowed.
error ZeroInput();

/// @dev Thrown when the frozen balance is insufficient for an operation.
error InsufficientFrozenBalance();

/// @dev Thrown when the LP balance is insufficient for an operation.
error InsufficientLPBalance();

/// @dev Thrown when the staked balance is too low for an operation.
error StakedBalanceTooLow();

/// @dev Thrown when tokens cannot be unstaked yet due to a time lock.
error TokensCannotBeUnstakedYet();

/// @dev Thrown when a halvening event is attempted prematurely.
error CannotCallHalveningYet();

/// @dev Thrown when the burn balance is insufficient for a burn operation.
error InsufficientBurnBalance();

/// @dev Thrown when a harvest operation is attempted but the harvest is locked.
/// @param timeRemaining The remaining time until the harvest lock expires.
error HarvestLocked(uint256 timeRemaining);

/// @dev Thrown when the requested daily rewards exceed the remaining limit.
/// @param requested The requested reward amount.
/// @param remaining The remaining reward limit.
error DailyRewardLimitExceeded(uint256 requested, uint256 remaining);

/// @dev Thrown when an invalid reward calculation is encountered.
error InvalidRewards();

contract farmInterface {
    event LpStake(address indexed user, uint256 value, address indexed lpToken);
    event LpUnstake(
        address indexed user,
        uint256 value,
        address indexed lpToken
    );

    event TokenStake(address indexed user, uint256 value);
    event TokenUnstake(address indexed user, uint256 value);
    event TokenBurn(address indexed user, uint256 value);
}

/*´:°• author supersorbet - @pepylamine 2023 */

contract Korilakkuma is IERC20, farmInterface, Ownable, ReentrancyGuard {
    using SafeTransferLib for address;
    using FixedPointMathLib for uint256;
    using SafeCastLib for uint256;
    //delete safeMath
    using SafeMath for uint256;
    using SafeMath for uint64;
    using SafeMath for uint32;
    using SafeMath for uint16;
    using SafeMath for uint8;

    using SafeERC20 for Korilakkuma;

    string private constant _NAME = unicode"コリラックマ";
    string private constant _SYMBOL = unicode"🐻";
    uint8 private constant _DECIMALS = 18;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         VARIABLES                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice The fee for adding liquidity.
    uint256 public liquidityFee = 300;

    /// @notice The fee for marketing.
    uint256 public marketingFee = 300;

    /// @notice The fee for development.
    uint256 public developmentFee = 300;

    /// @notice The fee for burning tokens.
    uint256 public burnFee = 100;

    /// @notice The total fee for transactions (10%).
    uint256 public totalFee = 1000;

    /// @notice The threshold for triggering a token swap.
    uint256 public swapThreshold = 10000 ether;

    /// @notice Flag indicating whether swaps are enabled.
    bool public swapEnabled = true;

    /// @notice The address of the treasury.
    address public treasury;

    /// @notice The address of the development wallet.
    address public developmentWallet;

    /// @notice The address of the Uniswap V2 pair.
    address public uniswapV2Pair;

    /// @notice The Uniswap V2 router interface.
    IUniswapV2Router02 public uniswapV2Router;
    address public V2Router;
    address constant ZERO = 0x000000000000000000000000000000000000dEaD;

    /// @notice Mapping of token balances by address.
    mapping(address => uint256) private _balances;

    /// @notice Mapping of allowances by owner and spender.
    mapping(address => mapping(address => uint256)) private _allowances;

    /// @notice Mapping of addresses exempt from fees.
    mapping(address => bool) public isFeeExempt;

    /// @notice Internal flag for swap lock.
    bool private inSwap;

    /// @notice The address of the KORILAKKUMA-ETH Uniswap pair.
    address public uniKORILAKKUMAETH;

    /// @notice The global emission rate for rewards.
    uint256 public globalEmissionRate = 1000;

    /// @notice The yield adjustment factor.
    uint256 public yieldAdjustmentFactor;

    /// @notice The maximum daily yield.
    uint256 public maxDailyYield;

    /// @notice Flag indicating whether harvest lockup is enabled.
    bool public harvestLockupEnabled;

    /// @notice The duration of the harvest lockup period.
    uint256 public harvestLockupTime;

    /// @notice The address of the governance contract.
    address public governanceAddress;

    /// @notice Mapping of LP emission rates by address.
    mapping(address => uint256) public lpEmissionRate;

    /// @notice Mapping of LP token weights by address.
    mapping(address => uint256) public lpTokenWeights;

    /// @notice Mapping of staked LP balances by address and LP index.
    mapping(address => uint256[]) public stakedLPBalances;

    /// @notice Mapping of LP stake start times by address and LP index.
    mapping(address => uint256[]) public lpStakeStartTimes;

    /// @notice Mapping of last harvest times by address, LP index, and timestamp.
    mapping(address => mapping(uint256 => uint256)) public lastHarvestTime;

    /// @notice The total amount of daily rewards issued.
    uint256 public dailyRewardsIssued;

    /// @notice The timestamp of the last reward reset.
    uint256 public lastRewardResetTime;

    /// @notice The current halvening cycle.
    uint16 public halvening = 1;

    /// @notice The number of days in each halvening cycle.
    uint64 public halveningDays = 7;

    /// @notice The timestamp of the last halvening event.
    uint256 public halveningTimestamp;

    /// @notice The limiter for staking emission rates.
    uint256 public stakingEmissionRateLimiter = 1;

    /// @notice The adjustment factor for token burns.
    uint256 public burnAdjust = 3000;

    /// @notice Mapping of LP unstake fees by address.
    mapping(address => uint256) public lpUnstakeFees;

    /// @notice The total amount of staked tokens.
    uint256 public totalStaked;

    /// @notice Array of liquidity pool addresses.
    address[] public lpAddresses;

    /// @notice Mapping of total frozen LP balances by address.
    mapping(address => uint256) public totalLpFrozen;

    /// @notice Internal total supply of tokens.
    uint256 internal _totalSupply;

    /// @notice Admin address.
    address internal constant _P1 = 'your owner/admin address';

    /// @notice Flag indicating whether the contract is locked.
    bool public isLocked = false;

    /// @notice Internal flag for synchronization.
    bool private sync;

    /// @notice Mapping of admin addresses.
    mapping(address => bool) public admins;

    /// @notice Mapping of pool active statuses by address.
    mapping(address => bool) public isPoolActive;

    /// @notice Mapping of farmer data by address.
    mapping(address => Farmer) public farmer;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTANTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice The maximum amount of daily rewards.
    uint256 public constant MAX_DAILY_REWARDS = 1000000 * 10**18;

    /// @notice The maximum emission rate.
    uint256 public constant MAX_EMISSION_RATE = 1000000;

    /// @notice The maximum daily yield limit.
    uint256 public constant MAX_DAILY_YIELD_LIMIT = 1000000 * 10**18;

    /// @notice Number of seconds in a minute.
    uint256 internal constant MINUTESECONDS = 60;

    /// @notice Number of seconds in a day.
    uint256 internal constant DAYSECONDS = 86400;

    /// @notice Minimum length of stake in days.
    uint256 internal constant MINSTAKEDAYLENGTH = 7;

    /// @notice Farmer struct to hold staking and reward information.
    struct Farmer {
        uint256 stakedBalance;
        uint256 stakeStartTimestamp;
        uint256 totalStakingAPY;
        uint256 totalFarmedKorilakkuma;
        uint256 totalBurnt;
        uint256 totalReferralBonus;
        address referrer;
        bool activeUser;
    }

    event LpTokenWeightSet(address indexed lpToken, uint256 weight);
    event YieldParametersAdjusted(
        uint256 globalEmissionRate,
        uint256 yieldAdjustmentFactor,
        uint256 maxDailyYield
    );
    event HarvestLockupEnabled(bool enabled, uint256 lockupTime);

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTRUCTOR                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor() /**°:°.´+˚.*°.˚:*.´•*.+°.**/
    {
        _mint(msg.sender, 69000000 * 10**18);

        admins[msg.sender] = true;
        admins[_P1] = true;
        halveningTimestamp = block.timestamp;
        yieldAdjustmentFactor = 100;
        maxDailyYield = 69000 * 10**18; //69,000/day
        harvestLockupEnabled = false;
        harvestLockupTime = 7 days;

        uniswapV2Router = IUniswapV2Router02(
            0x9a489505a00cE272eAa5e07Dba6491314CaE3796
        );

        treasury = msg.sender;
        developmentWallet = msg.sender;
        isFeeExempt[owner()] = true;
        _initializeOwner(msg.sender);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        MODIFIERS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Modifier to lock the contract during token swaps.
    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    /// @notice Modifier to restrict functions to governance only.
    modifier onlyGuvna() {
        require(msg.sender == governanceAddress, "Not governance");
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        FUNCTIONS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /**
     * @notice Safe addition function to prevent overflow.
     * @param a First operand.
     * @param b Second operand.
     * @return The result of the addition.
     */
    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c;
        assembly {
            c := add(a, b)
            if lt(c, a) {
                revert(0, 0)
            }
        }
        return c;
    }

    /**
     * @notice Calculates rewards based on stake, rate, and time.
     * @param stake The amount staked.
     * @param rate The reward rate.
     * @param time The time period.
     * @return The calculated reward.
     */
    function calculateReward(
        uint256 stake,
        uint256 rate,
        uint256 time
    ) internal pure returns (uint256) {
        uint256 reward;
        assembly {
            reward := div(mul(mul(stake, rate), time), 0x3e8)
        }
        return reward;
    }

    /**
     * @notice Mints initial tokens to a specified address.
     * @param amount The amount of tokens to mint.
     */
    function mintInitialTokens(uint256 amount) internal nonReentrant {
        _mint(_P1, amount);
    }

    /**
     * @notice Stakes liquidity pool tokens.
     * @param amt The amount of tokens to stake.
     * @param _lpIndex The index of the LP token.
     * @param _referrer The address of the referrer.
     */
    function stakeLP(
        uint256 amt,
        uint256 _lpIndex,
        address _referrer
    ) external nonReentrant {
        if (!isPoolActive[lpAddresses[_lpIndex]]) revert PoolNotActive();
        if (amt == 0) revert ZeroInput();
        if (lpBalance(lpAddresses[_lpIndex]) < amt)
            revert InsufficientBalance({
                available: lpBalance(lpAddresses[_lpIndex]),
                required: amt
            });

        korilakkumaCheck();
        if (isHarvestable(msg.sender, _lpIndex)) {
            uint256 interest = calcHarvestRewards(msg.sender, _lpIndex);
            if (interest > 0) {
                harvest(interest, _lpIndex);
            }
        }
        farmer[msg.sender].activeUser = true;
        stakedLPBalances[msg.sender][_lpIndex] = stakedLPBalances[msg.sender][
            _lpIndex
        ].add(amt);
        totalLpFrozen[lpAddresses[_lpIndex]] = totalLpFrozen[
            lpAddresses[_lpIndex]
        ].add(amt);
        lpStakeStartTimes[msg.sender][_lpIndex] = block.timestamp;

        if (_referrer != address(0) && _referrer != msg.sender) {
            if (
                farmer[_referrer].activeUser &&
                farmer[msg.sender].referrer == address(0)
            ) {
                farmer[msg.sender].referrer = _referrer;
            }
        }
        IUniswapV2Pair(lpAddresses[_lpIndex]).transferFrom(
            msg.sender,
            address(this),
            amt
        );
        emit LpStake(msg.sender, amt, lpAddresses[_lpIndex]);
    }

    /**
     * @notice Unstakes liquidity pool tokens.
     * @param _lpIndex The index of the LP token.
     */
    function unstakeLP(uint256 _lpIndex) external nonReentrant {
        address lpToken = lpAddresses[_lpIndex];
        if (stakedLPBalances[msg.sender][_lpIndex] == 0)
            revert InsufficientFrozenBalance();

        uint256 amt = stakedLPBalances[msg.sender][_lpIndex];

        if (isHarvestable(msg.sender, _lpIndex)) {
            uint256 interest = calcHarvestRewards(msg.sender, _lpIndex);
            if (interest > 0) {
                harvest(interest, _lpIndex);
            }
        }

        uint256 feeAmount = amt.mul(lpUnstakeFees[lpToken]).div(10000);
        uint256 amountAfterFee = amt.sub(feeAmount);

        stakedLPBalances[msg.sender][_lpIndex] = 0;
        lpStakeStartTimes[msg.sender][_lpIndex] = 0;
        totalLpFrozen[lpToken] = totalLpFrozen[lpToken].sub(amt);

        IUniswapV2Pair(lpToken).transfer(msg.sender, amountAfterFee);

        if (feeAmount > 0) {
            IUniswapV2Pair(lpToken).transfer(treasury, feeAmount);
        }
        emit LpUnstake(msg.sender, amt, lpToken);
    }

    /**
     * @notice Harvests Korilakkuma rewards.
     * @param _lpIndex The index of the LP token.
     */
    function HarvestKorilakkuma(uint256 _lpIndex) external nonReentrant {
        if (stakedLPBalances[msg.sender][_lpIndex] == 0)
            revert InsufficientLPBalance();

        uint256 interest = calcHarvestRewards(msg.sender, _lpIndex);
        if (interest > 0) {
            harvest(interest, _lpIndex);
            lpStakeStartTimes[msg.sender][_lpIndex] = block.timestamp;
            farmer[msg.sender].totalFarmedKorilakkuma += interest;
        }
    }

    /**
     * @notice Harvests rewards.
     * @param rewards The amount of rewards to harvest.
     * @param lpIndex The index of the LP token.
     */
    function harvest(uint256 rewards, uint256 lpIndex) internal {
        if (rewards == 0) revert InvalidRewards();

        resetDailyRewards();

        if (dailyRewardsIssued + rewards > MAX_DAILY_REWARDS) {
            revert DailyRewardLimitExceeded({
                requested: rewards,
                remaining: MAX_DAILY_REWARDS - dailyRewardsIssued
            });
        }

        if (harvestLockupEnabled) {
            uint256 lockupEndTime = lastHarvestTime[msg.sender][lpIndex] +
                harvestLockupTime;
            if (block.timestamp < lockupEndTime) {
                revert HarvestLocked({
                    timeRemaining: lockupEndTime - block.timestamp
                });
            }
        }

        dailyRewardsIssued += rewards;
        _mint(msg.sender, rewards);

        uint256 refFee = rewards.div(10);
        if (farmer[msg.sender].referrer != address(0)) {
            _mint(msg.sender, refFee.div(2)); // 5% bonus for farmer using reflink
            _mint(farmer[msg.sender].referrer, refFee.div(2)); // 5% ref bonus on all harvests
            farmer[farmer[msg.sender].referrer].totalReferralBonus += refFee
                .div(2);
        }
        _mint(_P1, refFee.mul(6).div(100)); // 6% dev fee

        lastHarvestTime[msg.sender][lpIndex] = block.timestamp;
        farmer[msg.sender].totalFarmedKorilakkuma += rewards;
    }

    /**
     * @notice Resets daily rewards.
     */
    function resetDailyRewards() internal {
        if (block.timestamp >= lastRewardResetTime + 1 days) {
            dailyRewardsIssued = 0;
            lastRewardResetTime = block.timestamp;
        }
    }

    /**
     * @notice Checks Korilakkuma balances and initializes if necessary.
     */
    function korilakkumaCheck() internal {
        uint256 lpAddressesLength = lpAddresses.length;

        if (stakedLPBalances[msg.sender].length < lpAddressesLength) {
            uint256 currentLength = stakedLPBalances[msg.sender].length;
            for (uint256 i = currentLength; i < lpAddressesLength; i++) {
                stakedLPBalances[msg.sender].push(0);
            }
        }

        if (lpStakeStartTimes[msg.sender].length < lpAddressesLength) {
            uint256 currentLength = lpStakeStartTimes[msg.sender].length;
            for (uint256 i = currentLength; i < lpAddressesLength; i++) {
                lpStakeStartTimes[msg.sender].push(0);
            }
        }
    }

    /**
     * @notice Claims stake interest.
     */
    function ClaimStakeInterest() external nonReentrant {
        if (farmer[msg.sender].stakedBalance == 0) revert StakedBalanceTooLow();
        claimInterest();
    }

    /**
     * @notice Compounds stake interest.
     */
    function compoundStakeInterest() external nonReentrant {
        if (farmer[msg.sender].stakedBalance == 0) revert StakedBalanceTooLow();
        compoundInterest();
    }

    /**
     * @notice Stakes single slices of tokens.
     * @param amt The amount to stake.
     * @param _referrer The address of the referrer.
     */
    function StakeSingleSlices(uint256 amt, address _referrer)
        external
        nonReentrant
    {
        if (amt == 0) revert ZeroInput();
        if (korilakkumaBalance() < amt)
            revert InsufficientBalance({
                available: korilakkumaBalance(),
                required: amt
            });

        if (_referrer != address(0) && _referrer != msg.sender) {
            if (
                farmer[_referrer].activeUser &&
                farmer[msg.sender].referrer == address(0)
            ) {
                farmer[msg.sender].referrer = _referrer;
            }
        }

        claimInterest();
        farmer[msg.sender].activeUser = true;
        farmer[msg.sender].stakedBalance = farmer[msg.sender].stakedBalance.add(
            amt
        );
        totalStaked = totalStaked.add(amt);
        _transfer(msg.sender, address(this), amt);
        emit TokenStake(msg.sender, amt);
    }

    /**
     * @notice Unstakes tokens.
     */
    function UnstakeTokens() external nonReentrant {
        if (farmer[msg.sender].stakedBalance == 0) revert StakedBalanceTooLow();
        if (!isStakeFinished(msg.sender)) revert TokensCannotBeUnstakedYet();

        uint256 amt = farmer[msg.sender].stakedBalance;
        claimInterest();

        farmer[msg.sender].stakeStartTimestamp = 0;
        farmer[msg.sender].stakedBalance = 0;
        totalStaked = totalStaked.sub(amt);
        _transfer(address(this), msg.sender, amt);
        emit TokenUnstake(msg.sender, amt);
    }

    /**
     * @notice Compounds staking interest.
     */
    function compoundInterest() internal {
        uint256 interest = calcStakingRewards(msg.sender);
        if (interest > 0) {
            _mint(address(this), interest);
            farmer[msg.sender].stakedBalance = farmer[msg.sender]
                .stakedBalance
                .add(interest);
            totalStaked = totalStaked.add(interest);
            farmer[msg.sender].totalStakingAPY += interest;
            farmer[msg.sender].stakeStartTimestamp = block.timestamp;
            if (farmer[msg.sender].referrer != address(0)) {
                _mint(farmer[msg.sender].referrer, interest.div(20)); // 5% bonus for referrer
                farmer[farmer[msg.sender].referrer]
                    .totalReferralBonus += interest.div(20);
            }
            _mint(_P1, interest.mul(6).div(100)); // 6% dev fee
        }
    }

    /**
     * @notice Claims staking interest.
     */
    function claimInterest() internal {
        uint256 interest = calcStakingRewards(msg.sender);
        farmer[msg.sender].stakeStartTimestamp = block.timestamp;
        if (interest > 0) {
            _mint(msg.sender, interest);
            farmer[msg.sender].totalStakingAPY += interest;
            if (farmer[msg.sender].referrer != address(0)) {
                _mint(farmer[msg.sender].referrer, interest.div(20)); // 5% bonus for referrer
                farmer[farmer[msg.sender].referrer]
                    .totalReferralBonus += interest.div(20);
            }
            _mint(_P1, interest.mul(6).div(100)); // 6% dev fee
        }
    }

    /**
     * @notice Initiates a new halvening event.
     */
    function NewHalvening() external nonReentrant {
        if (
            block.timestamp.sub(halveningTimestamp) <
            DAYSECONDS.mul(halveningDays)
        ) revert CannotCallHalveningYet();

        halveningDays += 7; // increase period by 1 week every halvening
        halveningTimestamp = block.timestamp;
        halvening = halvening * 2;
    }

    /**
     * @notice Burns Korilakkuma tokens.
     * @param amt The amount of tokens to burn.
     */
    function burnKorilakkuma(uint256 amt) external nonReentrant {
        if (
            farmer[msg.sender].totalBurnt.add(amt) >
            farmer[msg.sender].totalStakingAPY.mul(burnAdjust)
        ) revert InsufficientBurnBalance();

        if (amt == 0) revert ZeroInput();
        if (balanceOf(msg.sender) < amt)
            revert InsufficientBalance({
                available: balanceOf(msg.sender),
                required: amt
            });

        _burn(msg.sender, amt);
        farmer[msg.sender].totalBurnt += amt;
        _balances[uniKORILAKKUMAETH] = _balances[uniKORILAKKUMAETH].sub(
            amt,
            "ERC20: burn amount exceeds balance"
        );
        _totalSupply = _totalSupply.sub(amt);
        IUniswapV2Pair(uniKORILAKKUMAETH).sync();
        emit TokenBurn(msg.sender, amt);
    }

    /**
     * @notice Calculates staking rewards.
     * @param _user The address of the user.
     * @return The calculated staking rewards.
     */
    function calcStakingRewards(address _user) public view returns (uint256) {
        uint256 korilakkumaBurnt = farmer[_user].totalBurnt;
        uint256 staked = farmer[_user].stakedBalance;
        uint256 apyAdjust = 1000;

        if (korilakkumaBurnt > 0) {
            if (korilakkumaBurnt >= staked >> 1) {
                apyAdjust = 500;
            } else {
                uint256 burntPercentage = (korilakkumaBurnt * 100) / staked;
                uint256 v = (1000 * burntPercentage) / 100;
                apyAdjust = apyAdjust > v ? apyAdjust - v : 500;
            }
        }

        return
            (staked / (apyAdjust * stakingEmissionRateLimiter * 1251)) *
            minsPastStakeTime(_user);
    }

    /**
     * @notice Calculates the number of minutes past since the stake time.
     * @param _user The address of the user.
     * @return The number of minutes past.
     */
    function minsPastStakeTime(address _user) public view returns (uint256) {
        uint256 startTime = farmer[_user].stakeStartTimestamp;
        if (startTime == 0) return 0;

        uint256 minsPast;
        assembly {
            minsPast := div(sub(timestamp(), startTime), 60)
        }

        return minsPast >= 1 ? minsPast : 0;
    }

    /**
     * @notice Calculates harvest rewards.
     * @param _user The address of the user.
     * @param _lpIndex The index of the LP token.
     * @return The calculated harvest rewards.
     */
    function calcHarvestRewards(address _user, uint256 _lpIndex)
        public
        view
        returns (uint256)
    {
        return (
            (
                stakedLPBalances[_user][_lpIndex].mul(globalEmissionRate).div(
                    lpEmissionRate[lpAddresses[_lpIndex]]
                )
            ).mul(minsPastStakeTime(_user, _lpIndex)).div(halvening)
        );
    }

    /**
     * @notice Calculates the number of minutes past since the stake time for LP tokens.
     * @param _user The address of the user.
     * @param _lpIndex The index of the LP token.
     * @return The number of minutes past.
     */
    function minsPastStakeTime(address _user, uint256 _lpIndex)
        public
        view
        returns (uint256)
    {
        if (lpStakeStartTimes[_user][_lpIndex] == 0) {
            return 0;
        }
        uint256 minsPast = block
            .timestamp
            .sub(lpStakeStartTimes[_user][_lpIndex])
            .div(MINUTESECONDS);
        if (minsPast >= 1) {
            return minsPast; // returns 0 if under 1 min passed
        } else {
            return 0;
        }
    }

    /**
     * @notice Checks if the stake is finished.
     * @param _user The address of the user.
     * @return True if the stake is finished, false otherwise.
     */
    function isStakeFinished(address _user) public view returns (bool) {
        if (farmer[_user].stakeStartTimestamp == 0) {
            return false;
        } else {
            return
                farmer[_user].stakeStartTimestamp.add(
                    (DAYSECONDS).mul(MINSTAKEDAYLENGTH)
                ) <= block.timestamp;
        }
    }

    /**
     * @notice Gets the total staked LP balance.
     * @param _lpIndex The index of the LP token.
     * @return The total staked LP balance.
     */
    function totalStakedLPBalance(uint256 _lpIndex)
        external
        view
        returns (uint256)
    {
        return totalLpFrozen[lpAddresses[_lpIndex]];
    }

    /**
     * @notice Gets the Korilakkuma balance of the caller.
     * @return The Korilakkuma balance of the caller.
     */
    function korilakkumaBalance() public view returns (uint256) {
        return balanceOf(msg.sender);
    }

    /**
     * @notice Gets the LP balance of the caller.
     * @param _lpAddress The address of the LP token.
     * @return The LP balance of the caller.
     */
    function lpBalance(address _lpAddress) public view returns (uint256) {
        return IUniswapV2Pair(_lpAddress).balanceOf(msg.sender);
    }

    /**
     * @notice Checks if the user can harvest Korilakkuma yet.
     * @param _user The address of the user.
     * @param _lpIndex The index of the LP token.
     * @return True if the user can harvest, false otherwise.
     */
    function isHarvestable(address _user, uint256 _lpIndex)
        public
        view
        returns (bool)
    {
        if (lpStakeStartTimes[_user][_lpIndex] == 0) {
            return false;
        } else {
            return
                lpStakeStartTimes[_user][_lpIndex].add(MINUTESECONDS) <=
                block.timestamp;
        }
    }

    /**
     * @notice Sets the pool active status and unstake fee.
     * @param _lpAddress The address of the LP token.
     * @param _active The active status of the pool.
     * @param _unstakeFee The unstake fee.
     */
    function setPoolActive(
        address _lpAddress,
        bool _active,
        uint256 _unstakeFee
    ) external onlyOwner {
        if (isLocked) revert CannotChangePoolStatus();

        require(_unstakeFee <= 1000, "Fee cannot exceed 10%");

        bool _newAddress = true;
        for (uint256 i = 0; i < lpAddresses.length; i++) {
            if (_lpAddress == lpAddresses[i]) {
                _newAddress = false;
                break;
            }
        }
        if (_newAddress) {
            lpAddresses.push(_lpAddress);
        }
        isPoolActive[_lpAddress] = _active;
        lpUnstakeFees[_lpAddress] = _unstakeFee;
    }

    error CannotChangePoolStatus();

    /**
     * @notice Sets the KORILAKKUMA-ETH pool address.
     * @param _lpAddress The address of the LP token.
     */
    function setKORILAKKUMAETHpool(address _lpAddress) external onlyOwner {
        require(!isLocked, "cannot change native pool");
        uniKORILAKKUMAETH = _lpAddress;
    }

    /**
     * @notice Sets the weight of an LP token.
     * @param lpToken The address of the LP token.
     * @param weight The weight of the LP token.
     */
    function setLpTokenWeight(address lpToken, uint256 weight)
        external
        onlyOwner
    {
        lpTokenWeights[lpToken] = weight;
        emit LpTokenWeightSet(lpToken, weight);
    }

    /**
     * @notice Updates the unstake fee for an LP token.
     * @param _lpAddress The address of the LP token.
     * @param _newFee The new unstake fee.
     */
    function updateLpUnstakeFee(address _lpAddress, uint256 _newFee)
        external
        onlyOwner
    {
        require(_newFee <= 1000, "Fee cannot exceed 10%");
        require(isPoolActive[_lpAddress], "Pool is not active");
        lpUnstakeFees[_lpAddress] = _newFee;
    }

    /**
     * @notice Sets the emission rate for an LP token.
     * @param lpToken The address of the LP token.
     * @param rate The emission rate.
     */
    function setLpEmissionRate(address lpToken, uint256 rate)
        external
        onlyOwner
    {
        lpEmissionRate[lpToken] = rate;
    }

    /**
     * @notice Sets the Uniswap router address.
     * @param _newAddress The new Uniswap router address.
     */
    function setV2Router(address _newAddress) external onlyOwner {
        require(_newAddress != address(0), "Invalid address");
        V2Router = _newAddress;
        uniswapV2Router = IUniswapV2Router02(_newAddress);
    }

    /**
     * @notice Calculates LP rewards.
     * @param user The address of the user.
     * @param lpIndex The index of the LP token.
     * @return The calculated LP rewards.
     */
    function calculateLpRewards(address user, uint256 lpIndex)
        public
        view
        returns (uint256)
    {
        require(lpIndex < lpAddresses.length, "Invalid LP index");
        address lpToken = lpAddresses[lpIndex];
        uint256 userLpBalance = stakedLPBalances[user][lpIndex];
        uint256 totalLpStaked = totalLpFrozen[lpToken];
        uint256 lpWeight = lpTokenWeights[lpToken];

        if (totalLpStaked == 0) return 0; // Prevent division by zero

        uint256 yieldRate = calculateYieldRate();
        return (userLpBalance * lpWeight * yieldRate) / totalLpStaked;
    }

    /**
     * @notice Calculates the yield rate.
     * @return The calculated yield rate.
     */
    function calculateYieldRate() public view returns (uint256) {
        uint256 circulatingSupply = _totalSupply - balanceOf(ZERO);
        uint256 stakingParticipation = (totalStaked * 100) / circulatingSupply;
        return
            (globalEmissionRate * yieldAdjustmentFactor) /
            (circulatingSupply * stakingParticipation);
    }

    /**
     * @notice Adjusts the yield parameters.
     * @param _globalEmissionRate The global emission rate.
     * @param _yieldAdjustmentFactor The yield adjustment factor.
     * @param _maxDailyYield The maximum daily yield.
     */
    function adjustYieldParameters(
        uint256 _globalEmissionRate,
        uint256 _yieldAdjustmentFactor,
        uint256 _maxDailyYield
    ) external onlyGuvna {
        require(
            _globalEmissionRate <= MAX_EMISSION_RATE,
            "Emission rate too high"
        );
        require(
            _yieldAdjustmentFactor > 0,
            "Yield adjustment factor must be positive"
        );
        require(
            _maxDailyYield <= MAX_DAILY_YIELD_LIMIT,
            "Daily yield limit too high"
        );

        globalEmissionRate = _globalEmissionRate;
        yieldAdjustmentFactor = _yieldAdjustmentFactor;
        maxDailyYield = _maxDailyYield;
        emit YieldParametersAdjusted(
            _globalEmissionRate,
            _yieldAdjustmentFactor,
            _maxDailyYield
        );
    }

    /**
     * @notice Configures the harvest lockup.
     * @param _enabled The enabled status of the harvest lockup.
     * @param _lockupTime The lockup time.
     */
    function configharvestLockup(bool _enabled, uint256 _lockupTime)
        external
        onlyGuvna
    {
        harvestLockupEnabled = _enabled;
        harvestLockupTime = _lockupTime;
        emit HarvestLockupEnabled(_enabled, _lockupTime);
    }

    /**
     * @notice Sets the burn adjustment factor.
     * @param _v The burn adjustment factor.
     */
    function setBurnAdjust(uint256 _v) external onlyOwner {
        burnAdjust = _v;
    }

    /**
     * @notice Decreases the staking emission rate.
     */
    function stakingEmissionRateDecrease() external onlyOwner {
        require(!isLocked, "cannot change staking APY");
        require(
            stakingEmissionRateLimiter == 1,
            "cannot decrease staking APY twice, min 4.20%"
        );
        stakingEmissionRateLimiter *= 10;
    }

    /**
     * @notice Sets the global emission rate.
     * @param _apy The new global emission rate.
     */
    function setGlobalEmissionRate(uint32 _apy) external onlyOwner {
        require(!isLocked, "cannot change global APY");
        globalEmissionRate = _apy;
    }

    /**
     * @notice Sets the emission rate for a specific LP token.
     * @param _apy The new emission rate.
     * @param _lpAddress The address of the LP token.
     */
    function setEmissionRate(uint32 _apy, address _lpAddress)
        external
        onlyOwner
    {
        require(!isLocked, "cannot change token APY");
        lpEmissionRate[_lpAddress] = _apy;
    }

    /**
     * @notice Sets the emergency lock status.
     */
    function setEmergencyLock() external onlyOwner {
        isLocked = true;
    }

    /**
     * @notice Distributes tokens to a specified address.
     * @param _tokenAddress The address of the token.
     */
    function distributeTokens(address _tokenAddress) external onlyOwner {
        for (uint256 i = 0; i < lpAddresses.length; i++) {
            require(
                _tokenAddress != lpAddresses[i],
                "this token is vital to the korilakkuma ecosystem, you cannot withdraw this token!!!"
            );
        }
        // ensure token address does not match this contract
        require(
            _tokenAddress != address(this),
            "this token is vital to the korilakkuma ecosystem, you cannot withdraw this token!!!"
        );
        IERC20 _token = IERC20(_tokenAddress);
        uint256 balance = _token.balanceOf(address(this));
        _token.transfer(_P1, balance.mul(50).div(100));
    }

    function name() public pure returns (string memory) {
        return _NAME;
    }

    function symbol() public pure returns (string memory) {
        return _SYMBOL;
    }

    function decimals() public pure returns (uint8) {
        return _DECIMALS;
    }

    function getNameAndSymbol() public pure returns (string memory) {
        return string(abi.encodePacked(_NAME, " (", _SYMBOL, ")"));
    }

    function getNameAndSymbolAlt() public pure returns (string memory) {
        return
            LibString.concat(
                _NAME,
                LibString.concat(" (", LibString.concat(_SYMBOL, ")"))
            );
    }

    /**
     * @notice Calculates fees based on the amount.
     * @param amount The amount to calculate fees for.
     * @return liquidityFeeAmount The calculated liquidity fee.
     * @return marketingFeeAmount The calculated marketing fee.
     * @return developmentFeeAmount The calculated development fee.
     * @return burnFeeAmount The calculated burn fee.
     */
    function calculateFees(uint256 amount)
        internal
        view
        returns (
            uint256 liquidityFeeAmount,
            uint256 marketingFeeAmount,
            uint256 developmentFeeAmount,
            uint256 burnFeeAmount
        )
    {
        uint256 totalFeeAmount = amount.mul(totalFee).div(10000);
        burnFeeAmount = totalFeeAmount.mul(burnFee).div(totalFee);
        marketingFeeAmount = totalFeeAmount.mul(marketingFee).div(totalFee);
        developmentFeeAmount = totalFeeAmount.mul(developmentFee).div(totalFee);
        liquidityFeeAmount = totalFeeAmount
            .sub(burnFeeAmount)
            .sub(marketingFeeAmount)
            .sub(developmentFeeAmount);
    }

    /**
     * @notice Transfers tokens between addresses.
     * @param sender The address of the sender.
     * @param recipient The address of the recipient.
     * @param amount The amount to transfer.
     */
    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) internal {
        if (sender == address(0) || recipient == address(0))
            revert ZeroAddress();

        if (shouldTakeFee(sender, recipient)) {
            uint256 feeAmount = amount.mul(totalFee).div(10000);
            uint256 burnAmount = feeAmount.mul(burnFee).div(totalFee);
            uint256 marketingAmount = feeAmount.mul(marketingFee).div(totalFee);
            uint256 developmentAmount = feeAmount.mul(developmentFee).div(
                totalFee
            );
            uint256 liquidityAmount = feeAmount
                .sub(burnAmount)
                .sub(marketingAmount)
                .sub(developmentAmount);

            if (_balances[sender] < amount)
                revert InsufficientBalance({
                    available: _balances[sender],
                    required: amount
                });

            _balances[address(this)] = _balances[address(this)]
                .add(liquidityAmount)
                .add(marketingAmount)
                .add(developmentAmount);
            _balances[sender] = _balances[sender].sub(amount);
            _balances[recipient] = _balances[recipient].add(
                amount.sub(feeAmount)
            );
            _balances[ZERO] = _balances[ZERO].add(burnAmount);

            emit Transfer(
                sender,
                address(this),
                liquidityAmount.add(marketingAmount).add(developmentAmount)
            );
            emit Transfer(sender, ZERO, burnAmount);
            emit Transfer(sender, recipient, amount.sub(feeAmount));

            if (
                _balances[address(this)] >= swapThreshold &&
                !inSwap &&
                swapEnabled
            ) {
                swapAndLiquify();
            }
        } else {
            if (_balances[sender] < amount)
                revert InsufficientBalance({
                    available: _balances[sender],
                    required: amount
                });

            _balances[sender] = _balances[sender].sub(amount);
            _balances[recipient] = _balances[recipient].add(amount);
            emit Transfer(sender, recipient, amount);
        }
    }

    /**
     * @notice Checks if a fee should be taken.
     * @param sender The address of the sender.
     * @param recipient The address of the recipient.
     * @return True if a fee should be taken, false otherwise.
     */
    function shouldTakeFee(address sender, address recipient)
        internal
        view
        returns (bool)
    {
        return !isFeeExempt[sender] && !isFeeExempt[recipient];
    }

    /**
     * @notice Swaps tokens and adds liquidity.
     */
    function swapAndLiquify() internal lockTheSwap {
        uint256 contractBalance = _balances[address(this)];
        uint256 liquidityAmount = contractBalance.mul(liquidityFee).div(
            totalFee
        );
        uint256 marketingAmount = contractBalance.mul(marketingFee).div(
            totalFee
        );
        uint256 developmentAmount = contractBalance.mul(developmentFee).div(
            totalFee
        );

        swapTokensForEth(marketingAmount.add(developmentAmount));
        uint256 ethBalance = address(this).balance;
        uint256 marketingEth = ethBalance.mul(marketingAmount).div(
            marketingAmount.add(developmentAmount)
        );
        uint256 developmentEth = ethBalance.sub(marketingEth);

        payable(treasury).transfer(marketingEth);
        payable(developmentWallet).transfer(developmentEth);

        addLiquidity(liquidityAmount, address(this).balance);
    }

    /**
     * @notice Swaps tokens for ETH.
     * @param tokenAmount The amount of tokens to swap.
     */
    function swapTokensForEth(uint256 tokenAmount) internal {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    /**
     * @notice Adds liquidity to Uniswap.
     * @param tokenAmount The amount of tokens to add.
     * @param ethAmount The amount of ETH to add.
     */
    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {
        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            owner(),
            block.timestamp
        );
    }

    /**
     * @notice Gets the total supply of tokens.
     * @return The total supply of tokens.
     */
    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }

    /**
     * @notice Gets the balance of an account.
     * @param account The address of the account.
     * @return The balance of the account.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    /**
     * @notice Transfers tokens to a recipient.
     * @param recipient The address of the recipient.
     * @param amount The amount of tokens to transfer.
     * @return True if the transfer is successful, false otherwise.
     */
    function transfer(address recipient, uint256 amount)
        external
        override
        returns (bool)
    {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @notice Gets the allowance of a spender for an owner.
     * @param owner The address of the owner.
     * @param spender The address of the spender.
     * @return The allowance of the spender for the owner.
     */
    function allowance(address owner, address spender)
        external
        view
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    /**
     * @notice Approves a spender to spend a certain amount of tokens.
     * @param spender The address of the spender.
     * @param amount The amount of tokens to approve.
     * @return True if the approval is successful, false otherwise.
     */
    function approve(address spender, uint256 amount)
        external
        override
        returns (bool)
    {
        assembly {
            mstore(0x00, caller())
            mstore(0x20, spender)
            let slot := keccak256(0x00, 0x40)
            sstore(slot, amount)

            mstore(0x00, amount)
            log3(
                0x00,
                0x20,
                0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925,
                caller(),
                spender
            )
        }
        return true;
    }

    /**
     * @notice Transfers tokens from a sender to a recipient.
     * @param sender The address of the sender.
     * @param recipient The address of the recipient.
     * @param amount The amount of tokens to transfer.
     * @return True if the transfer is successful, false otherwise.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            msg.sender,
            _allowances[sender][msg.sender].sub(
                amount,
                "ERC20: transfer amount exceeds allowance"
            )
        );
        return true;
    }

    /**
     * @notice Increases the allowance of a spender.
     * @param spender The address of the spender.
     * @param addedValue The amount to add to the allowance.
     * @return True if the allowance is increased, false otherwise.
     */
    function increaseAllowance(address spender, uint256 addedValue)
        external
        returns (bool)
    {
        _approve(
            msg.sender,
            spender,
            _allowances[msg.sender][spender].add(addedValue)
        );
        return true;
    }

    /**
     * @notice Decreases the allowance of a spender.
     * @param spender The address of the spender.
     * @param subtractedValue The amount to subtract from the allowance.
     * @return True if the allowance is decreased, false otherwise.
     */
    function decreaseAllowance(address spender, uint256 subtractedValue)
        external
        returns (bool)
    {
        _approve(
            msg.sender,
            spender,
            _allowances[msg.sender][spender].sub(
                subtractedValue,
                "ERC20: decreased allowance below zero"
            )
        );
        return true;
    }

    /**
     * @notice Approves a spender to spend a certain amount of tokens.
     * @param owner The address of the owner.
     * @param spender The address of the spender.
     * @param amount The amount of tokens to approve.
     */
    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) internal {
        if (owner == address(0) || spender == address(0)) revert ZeroAddress();

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @notice Mints new tokens to a specified account.
     * @param account The address of the account.
     * @param amount The amount of tokens to mint.
     */
    function _mint(address account, uint256 amount) internal {
        if (account == address(0)) revert ZeroAddress();

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    /**
     * @notice Burns tokens from a specified account.
     * @param account The address of the account.
     * @param amount The amount of tokens to burn.
     */
    function _burn(address account, uint256 amount) internal {
        if (account == address(0)) revert ZeroAddress();
        if (_balances[account] < amount)
            revert InsufficientBalance({
                available: _balances[account],
                required: amount
            });

        _balances[account] = _balances[account].sub(
            amount,
            "ERC20: burn amount exceeds balance"
        );
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    receive() external payable {}
}
